From 601999f1a77b11d87e373d95fa3444fc64d71fdf Mon Sep 17 00:00:00 2001
From: KunYi <kunyi.chen@gmail.com>
Date: Thu, 29 Oct 2020 20:20:49 +0800
Subject: [PATCH] add support new board srg3352

the board support AAEON SRG-3352x IoT Gateway
---
 arch/arm/dts/srg3352.dts           | 102 +++++
 arch/arm/include/asm/mach-types.h  |   1 +
 arch/arm/mach-omap2/Kconfig        |   2 +
 arch/arm/mach-omap2/am33xx/Kconfig |  27 ++
 board/aaeon/srg3352/Kconfig        |  25 ++
 board/aaeon/srg3352/MAINTAINERS    |   6 +
 board/aaeon/srg3352/Makefile       |  12 +
 board/aaeon/srg3352/README         | 205 +++++++++
 board/aaeon/srg3352/board.c        | 656 +++++++++++++++++++++++++++++
 board/aaeon/srg3352/board.h        |  41 ++
 board/aaeon/srg3352/board_detect.c | 347 +++++++++++++++
 board/aaeon/srg3352/board_detect.h |  84 ++++
 board/aaeon/srg3352/mux.c          | 201 +++++++++
 board/aaeon/srg3352/u-boot.lds     | 165 ++++++++
 configs/srg3352_defconfig          |  63 +++
 include/configs/srg3352.h          | 351 +++++++++++++++
 16 files changed, 2288 insertions(+)
 create mode 100644 arch/arm/dts/srg3352.dts
 create mode 100644 board/aaeon/srg3352/Kconfig
 create mode 100644 board/aaeon/srg3352/MAINTAINERS
 create mode 100644 board/aaeon/srg3352/Makefile
 create mode 100644 board/aaeon/srg3352/README
 create mode 100644 board/aaeon/srg3352/board.c
 create mode 100644 board/aaeon/srg3352/board.h
 create mode 100644 board/aaeon/srg3352/board_detect.c
 create mode 100644 board/aaeon/srg3352/board_detect.h
 create mode 100644 board/aaeon/srg3352/mux.c
 create mode 100644 board/aaeon/srg3352/u-boot.lds
 create mode 100644 configs/srg3352_defconfig
 create mode 100644 include/configs/srg3352.h

diff --git a/arch/arm/dts/srg3352.dts b/arch/arm/dts/srg3352.dts
new file mode 100644
index 0000000000..c7bfed3a8d
--- /dev/null
+++ b/arch/arm/dts/srg3352.dts
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am33xx.dtsi"
+#include "am335x-bone-common.dtsi"
+
+/ {
+	model = "AAEON SRG3352 IoT gateway";
+	compatible = "aaeon,srg3352", "ti,am335x-bone-black", "ti,am335x-bone", "ti,am33xx";
+	chosen {
+		stdout-path = &uart0;
+		tick-timer = &timer2;
+	};
+};
+
+&ldo3_reg {
+	regulator-min-microvolt = <1800000>;
+	regulator-max-microvolt = <1800000>;
+	regulator-always-on;
+};
+
+&mmc1 {
+	vmmc-supply = <&vmmcsd_fixed>;
+	broken-cd;
+	cd-gpios = <>;
+};
+
+&mmc2 {
+	vmmc-supply = <&vmmcsd_fixed>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <0>;
+	phy-mode = "rgmii";
+};
+
+&cpsw_emac1 {
+	phy_id = <&davinci_mdio>, <1>;
+	phy-mode = "rgmii";
+};
+
+&am33xx_pinmux {
+	nxp_hdmi_bonelt_pins: nxp_hdmi_bonelt_pins {
+		pinctrl-single,pins = <
+			0x1b0 0x03      /* xdma_event_intr0, OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT */
+			0xa0 0x08       /* lcd_data0.lcd_data0, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xa4 0x08       /* lcd_data1.lcd_data1, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xa8 0x08       /* lcd_data2.lcd_data2, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xac 0x08       /* lcd_data3.lcd_data3, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xb0 0x08       /* lcd_data4.lcd_data4, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xb4 0x08       /* lcd_data5.lcd_data5, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xb8 0x08       /* lcd_data6.lcd_data6, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xbc 0x08       /* lcd_data7.lcd_data7, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xc0 0x08       /* lcd_data8.lcd_data8, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xc4 0x08       /* lcd_data9.lcd_data9, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xc8 0x08       /* lcd_data10.lcd_data10, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xcc 0x08       /* lcd_data11.lcd_data11, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xd0 0x08       /* lcd_data12.lcd_data12, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xd4 0x08       /* lcd_data13.lcd_data13, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xd8 0x08       /* lcd_data14.lcd_data14, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xdc 0x08       /* lcd_data15.lcd_data15, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+			0xe0 0x00       /* lcd_vsync.lcd_vsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+			0xe4 0x00       /* lcd_hsync.lcd_hsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+			0xe8 0x00       /* lcd_pclk.lcd_pclk, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+			0xec 0x00       /* lcd_ac_bias_en.lcd_ac_bias_en, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+		>;
+	};
+	nxp_hdmi_bonelt_off_pins: nxp_hdmi_bonelt_off_pins {
+		pinctrl-single,pins = <
+			0x1b0 0x03      /* xdma_event_intr0, OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT */
+		>;
+	};
+};
+
+&lcdc {
+	status = "okay";
+};
+
+/ {
+	hdmi {
+		compatible = "ti,tilcdc,slave";
+		i2c = <&i2c0>;
+		pinctrl-names = "default", "off";
+		pinctrl-0 = <&nxp_hdmi_bonelt_pins>;
+		pinctrl-1 = <&nxp_hdmi_bonelt_off_pins>;
+		status = "okay";
+	};
+};
+
+&rtc {
+	system-power-controller;
+};
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index 9f82efe007..f047b3eea7 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -5057,4 +5057,5 @@
 #define MACH_TYPE_NASM25               5112
 #define MACH_TYPE_TOMATO               5113
 #define MACH_TYPE_OMAP3_MRC3D          5114
+#define MACH_TYPE_SRG3352              5115
 #endif
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index d9bdcb355a..4f22d335af 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -201,8 +201,10 @@ source "board/ti/am43xx/Kconfig"
 source "board/ti/am335x/Kconfig"
 source "board/compulab/cm_t335/Kconfig"
 source "board/compulab/cm_t43/Kconfig"
+source "board/aaeon/srg3352/Kconfig"
 
 config SPL_LDSCRIPT
         default "arch/arm/mach-omap2/u-boot-spl.lds"
 
+
 endif
diff --git a/arch/arm/mach-omap2/am33xx/Kconfig b/arch/arm/mach-omap2/am33xx/Kconfig
index 2dac97a530..ada5dc696f 100644
--- a/arch/arm/mach-omap2/am33xx/Kconfig
+++ b/arch/arm/mach-omap2/am33xx/Kconfig
@@ -213,6 +213,33 @@ config TARGET_PDU001
 	  The PDU001 is a processor and display unit developed around
 	  the Computing-Module m2 from bytes at work AG.
 
+config TARGET_SRG3352
+	bool "Support SRG3352"
+	select BOARD_LATE_INIT
+	select DM
+	select DM_GPIO
+	select DM_SERIAL
+	imply CMD_DM
+	imply CMD_MMC
+	imply SPL_DM
+	imply SPL_DM_SEQ_ALIAS
+	imply SPL_ENV_SUPPORT
+	imply SPL_EXT_SUPPORT
+	imply SPL_FAT_SUPPORT
+	imply SPL_GPIO_SUPPORT
+	imply SPL_I2C_SUPPORT
+	imply SPL_LIBDISK_SUPPORT
+	imply SPL_MMC_SUPPORT
+	imply SPL_OF_LIBFDT
+	imply SPL_POWER_SUPPORT
+	imply SPL_SEPARATE_BSS
+	imply SPL_SERIAL_SUPPORT
+	imply SPL_SYS_MALLOC_SIMPLE
+	imply SPL_WATCHDOG_SUPPORT
+	imply SPL_YMODEM_SUPPORT
+	help
+	  Suppoer for AAEON SRG3352 family IoT Gateway
+
 endchoice
 
 endif
diff --git a/board/aaeon/srg3352/Kconfig b/board/aaeon/srg3352/Kconfig
new file mode 100644
index 0000000000..f1e1b7671e
--- /dev/null
+++ b/board/aaeon/srg3352/Kconfig
@@ -0,0 +1,25 @@
+
+if TARGET_SRG3352
+config SYS_BOARD
+	default "srg3352"
+
+config SYS_VENDOR
+	default "aaeon"
+
+config SYS_SOC
+	default "am33xx"
+
+config SYS_CONFIG_NAME
+	default "srg3352"
+
+config EEPROM_BUS_ADDRESS
+	int "Board EEPROM's I2C bus address"
+	range 0 8
+	default 0
+
+config EEPROM_CHIP_ADDRESS
+	hex "Board EEPROM's I2C chip address"
+	range 0 0xff
+	default 0x50
+
+endif
diff --git a/board/aaeon/srg3352/MAINTAINERS b/board/aaeon/srg3352/MAINTAINERS
new file mode 100644
index 0000000000..673d37413c
--- /dev/null
+++ b/board/aaeon/srg3352/MAINTAINERS
@@ -0,0 +1,6 @@
+SRG3352 IoT Gateway 
+M:	KunYi <kunyi.chen@gmail.com>
+S:	Maintained
+F:	board/aaeon/srg3352/
+F:	include/configs/srg3352.h
+F:	configs/srg3352_defconfig
diff --git a/board/aaeon/srg3352/Makefile b/board/aaeon/srg3352/Makefile
new file mode 100644
index 0000000000..8a4658e4b3
--- /dev/null
+++ b/board/aaeon/srg3352/Makefile
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Makefile
+#
+# Copyright (C) 2020 AAEON Technology Inc. - https://www.aaeon.com/
+
+ifeq ($(CONFIG_SKIP_LOWLEVEL_INIT),)
+obj-y	:= mux.o
+endif
+
+obj-y	+= board.o
+obj-y   += board_detect.o
diff --git a/board/aaeon/srg3352/README b/board/aaeon/srg3352/README
new file mode 100644
index 0000000000..19e0eccbac
--- /dev/null
+++ b/board/aaeon/srg3352/README
@@ -0,0 +1,205 @@
+Summary
+=======
+
+This document covers various features of the 'am335x_evm' build, and some of
+the related build targets (am335x_evm_uartN, etc).
+
+Hardware
+========
+
+The binary produced by this board supports, based on parsing of the EEPROM
+documented in TI's reference designs:
+- AM335x GP EVM
+- AM335x EVM SK
+- Beaglebone White
+- Beaglebone Black
+
+Customization
+=============
+
+Given that all of the above boards are reference platforms (and the
+Beaglebone platforms are OSHA), it is likely that this platform code and
+configuration will be used as the basis of a custom platform.  It is
+worth noting that aside from things such as NAND or MMC only being
+required if a custom platform makes use of these blocks, the following
+are required, depending on design:
+
+- GPIO is only required if DDR3 power is controlled in a way similar to
+  EVM SK
+- SPI is only required for SPI flash, or exposing the SPI bus.
+
+The following blocks are required:
+- I2C, to talk with the PMIC and ensure that we do not run afoul of
+  errata 1.0.24.
+
+When removing options as part of customization,
+CONFIG_EXTRA_ENV_SETTINGS will need additional care to update for your
+needs and to remove no longer relevant options as in some cases we
+define additional text blocks (such as for NAND or DFU strings).  Also
+note that all of the SPL options are grouped together, rather than with
+the IP blocks, so both areas will need their choices updated to reflect
+the custom design.
+
+NAND
+====
+
+The AM335x GP EVM ships with a 256MiB NAND available in most profiles.  In
+this example to program the NAND we assume that an SD card has been
+inserted with the files to write in the first SD slot and that mtdparts
+have been configured correctly for the board. All images are first loaded
+into memory, then written to NAND.
+
+Step-1: Building u-boot for NAND boot
+	Set following CONFIGxx options for NAND device.
+	CONFIG_SYS_NAND_PAGE_SIZE	number of main bytes in NAND page
+	CONFIG_SYS_NAND_OOBSIZE		number of OOB bytes in NAND page
+	CONFIG_SYS_NAND_BLOCK_SIZE	number of bytes in NAND erase-block
+	CONFIG_SYS_NAND_ECCPOS		ECC map for NAND page
+	CONFIG_NAND_OMAP_ECCSCHEME	(refer doc/README.nand)
+
+Step-2: Flashing NAND via MMC/SD
+	# select BOOTSEL to MMC/SD boot and boot from MMC/SD card
+	U-Boot # mmc rescan
+	# erase flash
+	U-Boot # nand erase.chip
+	U-Boot # env default -f -a
+	U-Boot # saveenv
+	# flash MLO. Redundant copies of MLO are kept for failsafe
+	U-Boot # load mmc 0 0x82000000 MLO
+	U-Boot # nand write 0x82000000 0x00000 0x20000
+	U-Boot # nand write 0x82000000 0x20000 0x20000
+	U-Boot # nand write 0x82000000 0x40000 0x20000
+	U-Boot # nand write 0x82000000 0x60000 0x20000
+	# flash u-boot.img
+	U-Boot # load mmc 0 0x82000000 u-boot.img
+	U-Boot # nand write 0x82000000 0x80000 0x60000
+	# flash kernel image
+	U-Boot # load mmc 0 0x82000000 uImage
+	U-Boot # nand write 0x82000000 ${nandsrcaddr} ${nandimgsize}
+	# flash filesystem image
+	U-Boot # load mmc 0 0x82000000 filesystem.img
+	U-Boot # nand write 0x82000000 ${loadaddress} 0x300000
+
+Step-3: Set BOOTSEL pin to select NAND boot, and POR the device.
+	The device should boot from images flashed on NAND device.
+
+NOR
+===
+
+The Beaglebone White can be equipped with a "memory cape" that in turn can
+have a NOR module plugged into it.  In this case it is then possible to
+program and boot from NOR.  Note that due to how U-Boot is designed we
+must build a specific version of U-Boot that knows we have NOR flash.  This
+build is named 'am335x_evm_nor'.  Further, we have a 'am335x_evm_norboot'
+build that will assume that the environment is on NOR rather than NAND.  In
+the following example we assume that and SD card has been populated with
+MLO and u-boot.img from a 'am335x_evm_nor' build and also contains the
+'u-boot.bin' from a 'am335x_evm_norboot' build.  When booting from NOR, a
+binary must be written to the start of NOR, with no header or similar
+prepended.  In the following example we use a size of 512KiB (0x80000)
+as that is how much space we set aside before the environment, as per
+the config file.
+
+U-Boot # mmc rescan
+U-Boot # load mmc 0 ${loadaddr} u-boot.bin
+U-Boot # protect off 08000000 +80000
+U-Boot # erase 08000000 +80000
+U-Boot # cp.b ${loadaddr} 08000000 ${filesize}
+
+Falcon Mode
+===========
+
+The default build includes "Falcon Mode" (see doc/README.falcon) via NAND,
+eMMC (or raw SD cards) and FAT SD cards.  Our default behavior currently is
+to read a 'c' on the console while in SPL at any point prior to loading the
+OS payload (so as soon as possible) to opt to booting full U-Boot.  Also
+note that while one can program Falcon Mode "in place" great care needs to
+be taken by the user to not 'brick' their setup.  As these are all eval
+boards with multiple boot methods, recovery should not be an issue in this
+worst-case however.
+
+Falcon Mode: eMMC
+=================
+
+The recommended layout in this case is:
+
+MMC BLOCKS      |--------------------------------| LOCATION IN BYTES
+0x0000 - 0x007F : MBR or GPT table               : 0x000000 - 0x020000
+0x0080 - 0x00FF : ARGS or FDT file               : 0x010000 - 0x020000
+0x0100 - 0x01FF : SPL.backup1 (first copy used)  : 0x020000 - 0x040000
+0x0200 - 0x02FF : SPL.backup2 (second copy used) : 0x040000 - 0x060000
+0x0300 - 0x06FF : U-Boot                         : 0x060000 - 0x0e0000
+0x0700 - 0x08FF : U-Boot Env + Redundant         : 0x0e0000 - 0x120000
+0x0900 - 0x28FF : Kernel                         : 0x120000 - 0x520000
+
+Note that when we run 'spl export' it will prepare to boot the kernel.
+This includes relocation of the uImage from where we loaded it to the entry
+point defined in the header.  As these locations overlap by default, it
+would leave us with an image that if written to MMC will not boot, so
+instead of using the loadaddr variable we use 0x81000000 in the following
+example.  In this example we are loading from the network, for simplicity,
+and assume a valid partition table already exists and 'mmc dev' has already
+been run to select the correct device.  Also note that if you previously
+had a FAT partition (such as on a Beaglebone Black) it is not enough to
+write garbage into the area, you must delete it from the partition table
+first.
+
+# Ensure we are able to talk with this mmc device
+U-Boot # mmc rescan
+U-Boot # tftp 81000000 am335x/MLO
+# Write to two of the backup locations ROM uses
+U-Boot # mmc write 81000000 100 100
+U-Boot # mmc write 81000000 200 100
+# Write U-Boot to the location set in the config
+U-Boot # tftp 81000000 am335x/u-boot.img
+U-Boot # mmc write 81000000 300 400
+# Load kernel and device tree into memory, perform export
+U-Boot # tftp 81000000 am335x/uImage
+U-Boot # run findfdt
+U-Boot # tftp ${fdtaddr} am335x/${fdtfile}
+U-Boot # run mmcargs
+U-Boot # spl export fdt 81000000 - ${fdtaddr}
+# Write the updated device tree to MMC
+U-Boot # mmc write ${fdtaddr} 80 80
+# Write the uImage to MMC
+U-Boot # mmc write 81000000 900 2000
+
+Falcon Mode: FAT SD cards
+=========================
+
+In this case the additional file is written to the filesystem.  In this
+example we assume that the uImage and device tree to be used are already on
+the FAT filesystem (only the uImage MUST be for this to function
+afterwards) along with a Falcon Mode aware MLO and the FAT partition has
+already been created and marked bootable:
+
+U-Boot # mmc rescan
+# Load kernel and device tree into memory, perform export
+U-Boot # load mmc 0:1 ${loadaddr} uImage
+U-Boot # run findfdt
+U-Boot # load mmc 0:1 ${fdtaddr} ${fdtfile}
+U-Boot # run mmcargs
+U-Boot # spl export fdt ${loadaddr} - ${fdtaddr}
+
+This will print a number of lines and then end with something like:
+   Using Device Tree in place at 80f80000, end 80f85928
+   Using Device Tree in place at 80f80000, end 80f88928
+So then you:
+
+U-Boot # fatwrite mmc 0:1 0x80f80000 args 8928
+
+Falcon Mode: NAND
+=================
+
+In this case the additional data is written to another partition of the
+NAND.  In this example we assume that the uImage and device tree to be are
+already located on the NAND somewhere (such as filesystem or mtd partition)
+along with a Falcon Mode aware MLO written to the correct locations for
+booting and mtdparts have been configured correctly for the board:
+
+U-Boot # nand read ${loadaddr} kernel
+U-Boot # load nand rootfs ${fdtaddr} /boot/am335x-evm.dtb
+U-Boot # run nandargs
+U-Boot # spl export fdt ${loadaddr} - ${fdtaddr}
+U-Boot # nand erase.part u-boot-spl-os
+U-Boot # nand write ${fdtaddr} u-boot-spl-os
diff --git a/board/aaeon/srg3352/board.c b/board/aaeon/srg3352/board.c
new file mode 100644
index 0000000000..f1e854568a
--- /dev/null
+++ b/board/aaeon/srg3352/board.c
@@ -0,0 +1,656 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * board.c
+ *
+ * Board functions for AAEON SRG335X IoT Gateway
+ *
+ *
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <spl.h>
+#include <serial.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clk_synthesizer.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <asm/omap_common.h>
+#include <asm/omap_sec_common.h>
+#include <asm/omap_mmc.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include <power/tps65217.h>
+#include <power/tps65910.h>
+#include <environment.h>
+#include <watchdog.h>
+#include "board_detect.h"
+#include "board.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* GPIO that controls power to DDR on EVM-SK */
+#define GPIO_TO_PIN(bank, gpio)		(32 * (bank) + (gpio))
+#define GPIO_DDR_VTT_EN		GPIO_TO_PIN(0, 7)
+#define ICE_GPIO_DDR_VTT_EN	GPIO_TO_PIN(0, 18)
+#define GPIO_PR1_MII_CTRL	GPIO_TO_PIN(3, 4)
+#define GPIO_MUX_MII_CTRL	GPIO_TO_PIN(3, 10)
+#define GPIO_FET_SWITCH_CTRL	GPIO_TO_PIN(0, 7)
+#define GPIO_PHY_RESET		GPIO_TO_PIN(2, 5)
+#define GPIO_ETH0_MODE		GPIO_TO_PIN(0, 11)
+#define GPIO_ETH1_MODE		GPIO_TO_PIN(1, 26)
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+#define GPIO0_RISINGDETECT	(AM33XX_GPIO0_BASE + OMAP_GPIO_RISINGDETECT)
+#define GPIO1_RISINGDETECT	(AM33XX_GPIO1_BASE + OMAP_GPIO_RISINGDETECT)
+
+#define GPIO0_IRQSTATUS1	(AM33XX_GPIO0_BASE + OMAP_GPIO_IRQSTATUS1)
+#define GPIO1_IRQSTATUS1	(AM33XX_GPIO1_BASE + OMAP_GPIO_IRQSTATUS1)
+
+#define GPIO0_IRQSTATUSRAW	(AM33XX_GPIO0_BASE + 0x024)
+#define GPIO1_IRQSTATUSRAW	(AM33XX_GPIO1_BASE + 0x024)
+
+/*
+ * Read header information from EEPROM into global structure.
+ */
+#ifdef CONFIG_TI_I2C_BOARD_DETECT
+void do_board_detect(void)
+{
+	enable_i2c0_pin_mux();
+#ifndef CONFIG_DM_I2C
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
+#endif
+	if (ti_i2c_eeprom_am_get(CONFIG_EEPROM_BUS_ADDRESS,
+				 CONFIG_EEPROM_CHIP_ADDRESS))
+		printf("ti_i2c_eeprom_init failed\n");
+}
+#endif
+
+#ifndef CONFIG_DM_SERIAL
+struct serial_device *default_serial_console(void)
+{
+	return &eserial1_device;
+}
+#endif
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+static const struct ddr_data ddr3_srg3352_data = {
+	.datardsratio0 = MT41K256M16HA125E_RD_DQS,
+	.datawdsratio0 = MT41K256M16HA125E_WR_DQS,
+	.datafwsratio0 = MT41K256M16HA125E_PHY_FIFO_WE,
+	.datawrsratio0 = MT41K256M16HA125E_PHY_WR_DATA,
+};
+
+static const struct cmd_control ddr3_srg3352_cmd_ctrl_data = {
+	.cmd0csratio = MT41K256M16HA125E_RATIO,
+	.cmd0iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41K256M16HA125E_RATIO,
+	.cmd1iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41K256M16HA125E_RATIO,
+	.cmd2iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+};
+
+static struct emif_regs ddr3_srg3352_emif_reg_data = {
+	.sdram_config = MT41K256M16HA125E_EMIF_SDCFG,
+	.ref_ctrl = MT41K256M16HA125E_EMIF_SDREF,
+	.sdram_tim1 = MT41K256M16HA125E_EMIF_TIM1,
+	.sdram_tim2 = MT41K256M16HA125E_EMIF_TIM2,
+	.sdram_tim3 = MT41K256M16HA125E_EMIF_TIM3,
+	.ocp_config = EMIF_OCP_CONFIG_BEAGLEBONE_BLACK,
+	.zq_config = MT41K256M16HA125E_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41K256M16HA125E_EMIF_READ_LATENCY,
+};
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+#ifdef CONFIG_SPL_SERIAL_SUPPORT
+	/* break into full u-boot on 'c' */
+	if (serial_tstc() && serial_getc() == 'c')
+		return 1;
+#endif
+
+#ifdef CONFIG_SPL_ENV_SUPPORT
+	env_init();
+	env_load();
+	if (env_get_yesno("boot_os") != 1)
+		return 1;
+#endif
+
+	return 0;
+}
+#endif
+
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+	int ind = get_sys_clk_index();
+
+	return &dpll_ddr3_400MHz[ind];
+}
+
+const struct dpll_params *get_dpll_mpu_params(void)
+{
+	int ind = get_sys_clk_index();
+
+	return &dpll_mpu_opp[ind][5];
+}
+
+static void scale_vcores_srg3352(int freq)
+{
+	int usb_cur_lim, mpu_vdd;
+
+#ifndef CONFIG_DM_I2C
+	if (i2c_probe(TPS65217_CHIP_PM))
+		return;
+#else
+	if (power_tps65217_init(0))
+		return;
+#endif
+	freq = MPUPLL_M_1000;
+	mpu_vdd = TPS65217_DCDC_VOLT_SEL_1325MV;
+	usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1800MA;
+
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_NONE,
+			       TPS65217_POWER_PATH,
+			       usb_cur_lim,
+			       TPS65217_USB_INPUT_CUR_LIMIT_MASK))
+		puts("tps65217_reg_write failure\n");
+
+	/* Set DCDC3 (CORE) voltage to 1.10V */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC3,
+				    TPS65217_DCDC_VOLT_SEL_1100MV)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
+
+	/* Set DCDC2 (MPU) voltage */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC2, mpu_vdd)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
+
+	/*
+	 * Set LDO3 to 1.8V and LDO4 to 3.3V for SRG3352
+	 */
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+				TPS65217_DEFLS1,
+				TPS65217_LDO_VOLTAGE_OUT_1_8,
+				TPS65217_LDO_MASK))
+		puts("tps65217_reg_write failure\n");
+
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+				TPS65217_DEFLS2,
+				TPS65217_LDO_VOLTAGE_OUT_3_3,
+				TPS65217_LDO_MASK))
+		puts("tps65217_reg_write failure\n");
+}
+
+void gpi2c_init(void)
+{
+	/* When needed to be invoked prior to BSS initialization */
+	static bool first_time = true;
+
+	if (first_time) {
+		enable_i2c0_pin_mux();
+#ifndef CONFIG_DM_I2C
+		i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED,
+			 CONFIG_SYS_OMAP24_I2C_SLAVE);
+#endif
+		first_time = false;
+	}
+}
+
+void scale_vcores(void)
+{
+	int freq;
+
+	gpi2c_init();
+	freq = am335x_get_efuse_mpu_max_freq(cdev);
+	scale_vcores_srg3352(freq);
+}
+
+void set_uart_mux_conf(void)
+{
+#if CONFIG_CONS_INDEX == 1
+	enable_uart0_pin_mux();
+#elif CONFIG_CONS_INDEX == 2
+	enable_uart1_pin_mux();
+#elif CONFIG_CONS_INDEX == 3
+	enable_uart2_pin_mux();
+#elif CONFIG_CONS_INDEX == 4
+	enable_uart3_pin_mux();
+#elif CONFIG_CONS_INDEX == 5
+	enable_uart4_pin_mux();
+#elif CONFIG_CONS_INDEX == 6
+	enable_uart5_pin_mux();
+#endif
+}
+
+void set_mux_conf_regs(void)
+{
+	enable_board_pin_mux();
+}
+
+const struct ctrl_ioregs ioregs_srg3352 = {
+	.cm0ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.cm1ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.cm2ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.dt0ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.dt1ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+};
+
+void sdram_init(void)
+{
+	config_ddr(400, &ioregs_srg3352,
+		   	&ddr3_srg3352_data,
+		   	&ddr3_srg3352_cmd_ctrl_data,
+			&ddr3_srg3352_emif_reg_data, 0);
+	
+}
+#endif
+
+#if defined(CONFIG_CLOCK_SYNTHESIZER) && (!defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)))
+static void request_and_set_gpio(int gpio, char *name, int val)
+{
+	int ret;
+
+	ret = gpio_request(gpio, name);
+	if (ret < 0) {
+		printf("%s: Unable to request %s\n", __func__, name);
+		return;
+	}
+
+	ret = gpio_direction_output(gpio, 0);
+	if (ret < 0) {
+		printf("%s: Unable to set %s  as output\n", __func__, name);
+		goto err_free_gpio;
+	}
+
+	gpio_set_value(gpio, val);
+
+	return;
+
+err_free_gpio:
+	gpio_free(gpio);
+}
+
+#define REQUEST_AND_SET_GPIO(N)	request_and_set_gpio(N, #N, 1);
+#define REQUEST_AND_CLR_GPIO(N)	request_and_set_gpio(N, #N, 0);
+
+/**
+ * RMII mode on ICEv2 board needs 50MHz clock. Given the clock
+ * synthesizer With a capacitor of 18pF, and 25MHz input clock cycle
+ * PLL1 gives an output of 100MHz. So, configuring the div2/3 as 2 to
+ * give 50MHz output for Eth0 and 1.
+ */
+static struct clk_synth cdce913_data = {
+	.id = 0x81,
+	.capacitor = 0x90,
+	.mux = 0x6d,
+	.pdiv2 = 0x2,
+	.pdiv3 = 0x2,
+};
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP) && defined(CONFIG_OF_CONTROL) && \
+	defined(CONFIG_DM_ETH) && defined(CONFIG_DRIVER_TI_CPSW)
+
+#define MAX_CPSW_SLAVES	2
+
+/* At the moment, we do not want to stop booting for any failures here */
+int ft_board_setup(void *fdt, bd_t *bd)
+{
+	const char *slave_path, *enet_name;
+	int enetnode, slavenode, phynode;
+	struct udevice *ethdev;
+	char alias[16];
+	u32 phy_id[2];
+	int phy_addr;
+	int i, ret;
+
+	/* phy address fixup needed only on beagle bone family */
+
+	for (i = 0; i < MAX_CPSW_SLAVES; i++) {
+		sprintf(alias, "ethernet%d", i);
+
+		slave_path = fdt_get_alias(fdt, alias);
+		if (!slave_path)
+			continue;
+
+		slavenode = fdt_path_offset(fdt, slave_path);
+		if (slavenode < 0)
+			continue;
+
+		enetnode = fdt_parent_offset(fdt, slavenode);
+		enet_name = fdt_get_name(fdt, enetnode, NULL);
+
+		ethdev = eth_get_dev_by_name(enet_name);
+		if (!ethdev)
+			continue;
+
+		phy_addr = cpsw_get_slave_phy_addr(ethdev, i);
+
+		/* check for phy_id as well as phy-handle properties */
+		ret = fdtdec_get_int_array_count(fdt, slavenode, "phy_id",
+						 phy_id, 2);
+		if (ret == 2) {
+			if (phy_id[1] != phy_addr) {
+				printf("fixing up phy_id for %s, old: %d, new: %d\n",
+				       alias, phy_id[1], phy_addr);
+
+				phy_id[0] = cpu_to_fdt32(phy_id[0]);
+				phy_id[1] = cpu_to_fdt32(phy_addr);
+				do_fixup_by_path(fdt, slave_path, "phy_id",
+						 phy_id, sizeof(phy_id), 0);
+			}
+		} else {
+			phynode = fdtdec_lookup_phandle(fdt, slavenode,
+							"phy-handle");
+			if (phynode < 0)
+				continue;
+
+			ret = fdtdec_get_int(fdt, phynode, "reg", -ENOENT);
+			if (ret < 0)
+				continue;
+
+			if (ret != phy_addr) {
+				printf("fixing up phy-handle for %s, old: %d, new: %d\n",
+				       alias, ret, phy_addr);
+
+				fdt_setprop_u32(fdt, phynode, "reg",
+						cpu_to_fdt32(phy_addr));
+			}
+		}
+	}
+
+	return 0;
+}
+
+#endif
+
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static bool prueth_is_mii = false;
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+#if defined(CONFIG_HW_WATCHDOG)
+	hw_watchdog_init();
+#endif
+
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+#if defined(CONFIG_CLOCK_SYNTHESIZER) && (!defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)))
+	if (0) {
+		int rv;
+		u32 reg;
+		bool eth0_is_mii = true;
+		bool eth1_is_mii = true;
+
+		REQUEST_AND_SET_GPIO(GPIO_PR1_MII_CTRL);
+		/* Make J19 status available on GPIO1_26 */
+		REQUEST_AND_CLR_GPIO(GPIO_MUX_MII_CTRL);
+
+		REQUEST_AND_SET_GPIO(GPIO_FET_SWITCH_CTRL);
+		/*
+		 * Both ports can be set as RMII-CPSW or MII-PRU-ETH using
+		 * jumpers near the port. Read the jumper value and set
+		 * the pinmux, external mux and PHY clock accordingly.
+		 * As jumper line is overridden by PHY RX_DV pin immediately
+		 * after bootstrap (power-up/reset), we need to sample
+		 * it during PHY reset using GPIO rising edge detection.
+		 */
+		REQUEST_AND_SET_GPIO(GPIO_PHY_RESET);
+		/* Enable rising edge IRQ on GPIO0_11 and GPIO 1_26 */
+		reg = readl(GPIO0_RISINGDETECT) | BIT(11);
+		writel(reg, GPIO0_RISINGDETECT);
+		reg = readl(GPIO1_RISINGDETECT) | BIT(26);
+		writel(reg, GPIO1_RISINGDETECT);
+		/* Reset PHYs to capture the Jumper setting */
+		gpio_set_value(GPIO_PHY_RESET, 0);
+		udelay(2);	/* PHY datasheet states 1uS min. */
+		gpio_set_value(GPIO_PHY_RESET, 1);
+
+		reg = readl(GPIO0_IRQSTATUSRAW) & BIT(11);
+		if (reg) {
+			writel(reg, GPIO0_IRQSTATUS1); /* clear irq */
+			/* RMII mode */
+			printf("ETH0, CPSW\n");
+			eth0_is_mii = false;
+		} else {
+			/* MII mode */
+			printf("ETH0, PRU\n");
+			cdce913_data.pdiv3 = 4;	/* 25MHz PHY clk */
+		}
+
+		reg = readl(GPIO1_IRQSTATUSRAW) & BIT(26);
+		if (reg) {
+			writel(reg, GPIO1_IRQSTATUS1); /* clear irq */
+			/* RMII mode */
+			printf("ETH1, CPSW\n");
+			gpio_set_value(GPIO_MUX_MII_CTRL, 1);
+			eth1_is_mii = false;
+		} else {
+			/* MII mode */
+			printf("ETH1, PRU\n");
+			cdce913_data.pdiv2 = 4;	/* 25MHz PHY clk */
+		}
+
+		if (eth0_is_mii != eth1_is_mii) {
+			printf("Unsupported Ethernet port configuration\n");
+			printf("Both ports must be set as RMII or MII\n");
+			hang();
+		}
+
+		prueth_is_mii = eth0_is_mii;
+
+		/* disable rising edge IRQs */
+		reg = readl(GPIO0_RISINGDETECT) & ~BIT(11);
+		writel(reg, GPIO0_RISINGDETECT);
+		reg = readl(GPIO1_RISINGDETECT) & ~BIT(26);
+		writel(reg, GPIO1_RISINGDETECT);
+
+		rv = setup_clock_synthesizer(&cdce913_data);
+		if (rv) {
+			printf("Clock synthesizer setup failed %d\n", rv);
+			return rv;
+		}
+
+		/* reset PHYs */
+		gpio_set_value(GPIO_PHY_RESET, 0);
+		udelay(2);	/* PHY datasheet states 1uS min. */
+		gpio_set_value(GPIO_PHY_RESET, 1);
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+	struct udevice *dev;
+#if !defined(CONFIG_SPL_BUILD)
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	set_board_info_env("SRG3352C");
+	set_project_info_env();
+
+	/*
+	 * Default FIT boot on HS devices. Non FIT images are not allowed
+	 * on HS devices.
+	 */
+	if (get_device_type() == HS_DEVICE)
+		env_set("boot_fit", "1");
+#endif
+
+#if !defined(CONFIG_SPL_BUILD)
+	/* try reading mac address from efuse */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!env_get("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("ethaddr", mac_addr);
+	}
+
+	mac_lo = readl(&cdev->macid1l);
+	mac_hi = readl(&cdev->macid1h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!env_get("eth1addr")) {
+		printf("<eth1addr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("eth1addr", mac_addr);
+	}
+
+#endif
+
+	if (!env_get("serial#")) {
+		char *board_serial = env_get("board_serial");
+		char *ethaddr = env_get("ethaddr");
+
+		if (!board_serial || !strncmp(board_serial, "unknown", 7))
+			env_set("serial#", ethaddr);
+		else
+			env_set("serial#", board_serial);
+	}
+
+	/* Just probe the potentially supported cdce913 device */
+	uclass_get_device(UCLASS_CLK, 0, &dev);
+
+	return 0;
+}
+#endif
+
+/* CPSW platdata */
+#if !CONFIG_IS_ENABLED(OF_CONTROL)
+struct cpsw_slave_data slave_data[] = {
+	{
+		.slave_reg_ofs  = CPSW_SLAVE0_OFFSET,
+		.sliver_reg_ofs = CPSW_SLIVER0_OFFSET,
+		.phy_addr       = 0,
+	},
+	{
+		.slave_reg_ofs  = CPSW_SLAVE1_OFFSET,
+		.sliver_reg_ofs = CPSW_SLIVER1_OFFSET,
+		.phy_addr       = 1,
+	},
+};
+
+struct cpsw_platform_data am335_eth_data = {
+	.cpsw_base		= CPSW_BASE,
+	.version		= CPSW_CTRL_VERSION_2,
+	.bd_ram_ofs		= CPSW_BD_OFFSET,
+	.ale_reg_ofs		= CPSW_ALE_OFFSET,
+	.cpdma_reg_ofs		= CPSW_CPDMA_OFFSET,
+	.mdio_div		= CPSW_MDIO_DIV,
+	.host_port_reg_ofs	= CPSW_HOST_PORT_OFFSET,
+	.channels		= 8,
+	.slaves			= 2,
+	.slave_data		= slave_data,
+	.ale_entries		= 1024,
+	.bd_ram_ofs		= 0x2000,
+	.mac_control		= 0x20,
+	.active_slave		= 0,
+	.mdio_base		= 0x4a101000,
+	.gmii_sel		= 0x44e10650,
+	.phy_sel_compat		= "ti,am3352-cpsw-phy-sel",
+	.syscon_addr		= 0x44e10630,
+	.macid_sel_compat	= "cpsw,am33xx",
+};
+
+struct eth_pdata cpsw_pdata = {
+	.iobase = 0x4a100000,
+	.phy_interface = 0,
+	.priv_pdata = &am335_eth_data,
+};
+
+U_BOOT_DEVICE(am335x_eth) = {
+	.name = "eth_cpsw",
+	.platdata = &cpsw_pdata,
+};
+#endif
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	if (!strcmp(name, "srg3352"))
+		return 0;
+
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+void board_fit_image_post_process(void **p_image, size_t *p_size)
+{
+	secure_boot_verify_image(p_image, p_size);
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(OF_CONTROL)
+static const struct omap_hsmmc_plat am335x_mmc0_platdata = {
+	.base_addr = (struct hsmmc *)OMAP_HSMMC1_BASE,
+	.cfg.host_caps = MMC_MODE_HS_52MHz | MMC_MODE_HS | MMC_MODE_4BIT,
+	.cfg.f_min = 400000,
+	.cfg.f_max = 52000000,
+	.cfg.voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195,
+	.cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT,
+};
+
+U_BOOT_DEVICE(am335x_mmc0) = {
+	.name = "omap_hsmmc",
+	.platdata = &am335x_mmc0_platdata,
+};
+
+static const struct omap_hsmmc_plat am335x_mmc1_platdata = {
+	.base_addr = (struct hsmmc *)OMAP_HSMMC2_BASE,
+	.cfg.host_caps = MMC_MODE_HS_52MHz | MMC_MODE_HS | MMC_MODE_8BIT,
+	.cfg.f_min = 400000,
+	.cfg.f_max = 52000000,
+	.cfg.voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195,
+	.cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT,
+};
+
+U_BOOT_DEVICE(am335x_mmc1) = {
+	.name = "omap_hsmmc",
+	.platdata = &am335x_mmc1_platdata,
+};
+#endif
diff --git a/board/aaeon/srg3352/board.h b/board/aaeon/srg3352/board.h
new file mode 100644
index 0000000000..dd94baf2d1
--- /dev/null
+++ b/board/aaeon/srg3352/board.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * board.h
+ *
+ * AAEON SRG3352 IoT Gateway information header
+ *
+ * Copyright (C) 2020, AAEON Technology Inc. - https://www.aaeon.com/
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+/**
+ * AM335X (EMIF_4D) EMIF REG_COS_COUNT_1, REG_COS_COUNT_2, and
+ * REG_PR_OLD_COUNT values to avoid LCDC DMA FIFO underflows and Frame
+ * Synchronization Lost errors. The values are the biggest that work
+ * reliably with offered video modes and the memory subsystem on the
+ * boards. These register have are briefly documented in "7.3.3.5.2
+ * Command Starvation" section of AM335x TRM. The REG_COS_COUNT_1 and
+ * REG_COS_COUNT_2 do not have any effect on current versions of
+ * AM335x.
+ */
+#define EMIF_OCP_CONFIG_BEAGLEBONE_BLACK       0x00141414
+#define EMIF_OCP_CONFIG_AM335X_EVM             0x003d3d3d
+
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_uart1_pin_mux(void);
+void enable_uart2_pin_mux(void);
+void enable_uart3_pin_mux(void);
+void enable_uart4_pin_mux(void);
+void enable_uart5_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(void);
+
+#endif
diff --git a/board/aaeon/srg3352/board_detect.c b/board/aaeon/srg3352/board_detect.c
new file mode 100644
index 0000000000..653d1d6c5b
--- /dev/null
+++ b/board/aaeon/srg3352/board_detect.c
@@ -0,0 +1,347 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *	Lokesh Vutla
+ *	Steve Kipisz
+ */
+
+#include <common.h>
+//#include <eeprom.h>
+#include <asm/arch/hardware.h>
+#include <asm/omap_common.h>
+#include <dm/uclass.h>
+//#include <env.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <errno.h>
+#include <malloc.h>
+
+#include "board_detect.h"
+
+#if !defined(CONFIG_DM_I2C)
+/**
+ * ti_i2c_eeprom_init - Initialize an i2c bus and probe for a device
+ * @i2c_bus: i2c bus number to initialize
+ * @dev_addr: Device address to probe for
+ *
+ * Return: 0 on success or corresponding error on failure.
+ */
+static int __maybe_unused ti_i2c_eeprom_init(int i2c_bus, int dev_addr)
+{
+	int rc;
+
+	if (i2c_bus >= 0) {
+		rc = i2c_set_bus_num(i2c_bus);
+		if (rc)
+			return rc;
+	}
+
+	return i2c_probe(dev_addr);
+}
+
+/**
+ * ti_i2c_eeprom_read - Read data from an EEPROM
+ * @dev_addr: The device address of the EEPROM
+ * @offset: Offset to start reading in the EEPROM
+ * @ep: Pointer to a buffer to read into
+ * @epsize: Size of buffer
+ *
+ * Return: 0 on success or corresponding result of i2c_read
+ */
+static int __maybe_unused ti_i2c_eeprom_read(int dev_addr, int offset,
+					     uchar *ep, int epsize)
+{
+	return i2c_read(dev_addr, offset, 2, ep, epsize);
+}
+#endif
+
+/**
+ * ti_eeprom_string_cleanup() - Handle eeprom programming errors
+ * @s:	eeprom string (should be NULL terminated)
+ *
+ * Some Board manufacturers do not add a NULL termination at the
+ * end of string, instead some binary information is kludged in, hence
+ * convert the string to just printable characters of ASCII chart.
+ */
+static void __maybe_unused ti_eeprom_string_cleanup(char *s)
+{
+	int i, l;
+
+	l = strlen(s);
+	for (i = 0; i < l; i++, s++)
+		if (*s < ' ' || *s > '~') {
+			*s = 0;
+			break;
+		}
+}
+
+__weak void gpi2c_init(void)
+{
+}
+
+static int __maybe_unused ti_i2c_eeprom_get(int bus_addr, int dev_addr,
+					    u32 header, u32 size, uint8_t *ep)
+{
+	u32 hdr_read;
+	int rc;
+
+#if defined(CONFIG_DM_I2C)
+	struct udevice *dev;
+	struct udevice *bus;
+
+	rc = uclass_get_device_by_seq(UCLASS_I2C, bus_addr, &bus);
+	if (rc)
+		return rc;
+	rc = dm_i2c_probe(bus, dev_addr, 0, &dev);
+	if (rc)
+		return rc;
+
+	/*
+	 * Read the header first then only read the other contents.
+	 */
+	rc = i2c_set_chip_offset_len(dev, 2);
+	if (rc)
+		return rc;
+
+	rc = dm_i2c_read(dev, 0, (uint8_t *)&hdr_read, 4);
+	if (rc)
+		return rc;
+
+	/* Corrupted data??? */
+	if (hdr_read != header) {
+		rc = dm_i2c_read(dev, 0, (uint8_t *)&hdr_read, 4);
+		/*
+		 * read the eeprom header using i2c again, but use only a
+		 * 1 byte address (some legacy boards need this..)
+		 */
+		if (rc) {
+			rc =  i2c_set_chip_offset_len(dev, 1);
+			if (rc)
+				return rc;
+
+			rc = dm_i2c_read(dev, 0, (uint8_t *)&hdr_read, 4);
+		}
+		if (rc)
+			return rc;
+	}
+	if (hdr_read != header)
+		return -1;
+
+	rc = dm_i2c_read(dev, 0, ep, size);
+	if (rc)
+		return rc;
+#else
+	u32 byte;
+
+	gpi2c_init();
+	rc = ti_i2c_eeprom_init(bus_addr, dev_addr);
+	if (rc)
+		return rc;
+
+	/*
+	 * Read the header first then only read the other contents.
+	 */
+	byte = 2;
+
+	rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+	if (rc)
+		return rc;
+
+	/* Corrupted data??? */
+	if (hdr_read != header) {
+		rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+		/*
+		 * read the eeprom header using i2c again, but use only a
+		 * 1 byte address (some legacy boards need this..)
+		 */
+		byte = 1;
+		if (rc) {
+			rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read,
+				      4);
+		}
+		if (rc)
+			return rc;
+	}
+	if (hdr_read != header)
+		return -1;
+
+	rc = i2c_read(dev_addr, 0x0, byte, ep, size);
+	if (rc)
+		return rc;
+#endif
+	return 0;
+}
+
+int __maybe_unused srg52_i2c_eeprom_set(const char *name, const u16 rev)
+{
+	struct srg52_eeprom_t *ep;
+
+	if (!name || !rev)
+		return -1;
+
+	ep = SRG52_EEPROM_DATA;
+	if (ep->magic == SRG52_EEPROM_HDR_MAGIC)
+		goto already_set;
+
+	/* Set to 0 all fields */
+	memset(ep, 0, sizeof(*ep));
+	strncpy((char *)ep->bname, name, SRG52_EEPROM_HDR_BRD_LEN);
+	ep->hwRev = rev;
+	/* Some dummy serial number to identify the platform */
+	strncpy((char *)ep->serial, "00000000000000000", SRG52_EEPROM_HDR_SN_LEN);
+	strncpy((char *)ep->manufacturer, "AAEON TECHNOLOGY INC.", SRG52_EEPROM_HDR_MNF_LEN);
+	/* Mark it with a valid magic header */
+	ep->magic = SRG52_EEPROM_HDR_MAGIC;
+	ep->rev = SRG52_EEPROM_HDR_REV;
+
+already_set:
+	return 0;
+}
+
+void __maybe_unused
+board_ti_get_eth_mac_addr(int index,
+			  u8 mac_addr[SRG52_EEPROM_HDR_ETH_ALEN])
+{
+#if 0
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		goto fail;
+
+	if (index < 0 || index >= TI_EEPROM_HDR_NO_OF_MAC_ADDR)
+		goto fail;
+
+	memcpy(mac_addr, ep->mac_addr[index], TI_EEPROM_HDR_ETH_ALEN);
+	return;
+
+fail:
+	memset(mac_addr, 0, TI_EEPROM_HDR_ETH_ALEN);
+#endif
+}
+
+#include "config.h"
+#include "generated/autoconf.h"
+#include "generated/timestamp_autogenerated.h"
+#include "generated/version_autogenerated.h"
+
+void __maybe_unused set_project_info_env(void)
+{
+        char bl_version[30];
+        char bl_date[30];
+
+        snprintf(bl_version, sizeof(bl_version), "%s", PLAIN_VERSION);
+        snprintf(bl_date, sizeof(bl_date), "%s", U_BOOT_DMI_DATE);
+
+        env_set("bl_vendor", CONFIG_SMBIOS_MANUFACTURER);
+        env_set("bl_version", bl_version);
+        env_set("bl_date", bl_date);
+
+        env_set("product_name", CONFIG_SMBIOS_PRODUCT_NAME);
+        env_set("product_version", "unknown");
+
+        env_set("board_vendor", CONFIG_SMBIOS_MANUFACTURER);
+        env_set("board_name", CONFIG_SMBIOS_PRODUCT_NAME);
+        env_set("board_version", "unknown");
+}
+
+void __maybe_unused set_board_info_env(char *name)
+{
+	char *unknown = "unknown";
+	char *defname = "SRG3352C";
+	//struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (name)
+		env_set("board_name", name);
+	#if 0
+	else if (ep->name)
+		env_set("board_name", ep->name);
+	#endif
+	else
+		env_set("board_name", defname);
+	#if 0
+	if (ep->version)
+		env_set("board_rev", ep->version);
+	else
+	#endif
+		env_set("board_rev", unknown);
+	#if 0
+	if (ep->serial)
+		env_set("board_serial", ep->serial);
+	else
+	#endif
+		env_set("board_serial", unknown);
+}
+
+static u64 mac_to_u64(u8 mac[6])
+{
+	int i;
+	u64 addr = 0;
+
+	for (i = 0; i < 6; i++) {
+		addr <<= 8;
+		addr |= mac[i];
+	}
+
+	return addr;
+}
+
+static void u64_to_mac(u64 addr, u8 mac[6])
+{
+	mac[5] = addr;
+	mac[4] = addr >> 8;
+	mac[3] = addr >> 16;
+	mac[2] = addr >> 24;
+	mac[1] = addr >> 32;
+	mac[0] = addr >> 40;
+}
+
+void board_ti_set_ethaddr(int index)
+{
+	uint8_t mac_addr[6];
+	int i;
+	u64 mac1, mac2;
+	u8 mac_addr1[6], mac_addr2[6];
+	int num_macs;
+	/*
+	 * Export any Ethernet MAC addresses from EEPROM.
+	 * The 2 MAC addresses in EEPROM define the address range.
+	 */
+	board_ti_get_eth_mac_addr(0, mac_addr1);
+	board_ti_get_eth_mac_addr(1, mac_addr2);
+
+	if (is_valid_ethaddr(mac_addr1) && is_valid_ethaddr(mac_addr2)) {
+		mac1 = mac_to_u64(mac_addr1);
+		mac2 = mac_to_u64(mac_addr2);
+
+		/* must contain an address range */
+		num_macs = mac2 - mac1 + 1;
+		if (num_macs <= 0)
+			return;
+
+		if (num_macs > 50) {
+			printf("%s: Too many MAC addresses: %d. Limiting to 50\n",
+			       __func__, num_macs);
+			num_macs = 50;
+		}
+
+		for (i = 0; i < num_macs; i++) {
+			u64_to_mac(mac1 + i, mac_addr);
+			if (is_valid_ethaddr(mac_addr)) {
+				eth_env_set_enetaddr_by_index("eth", i + index,
+							      mac_addr);
+			}
+		}
+	}
+}
+
+bool __maybe_unused board_srg52_was_eeprom_read(void)
+{
+	struct srg52_eeprom_t *ep = SRG52_EEPROM_DATA;
+
+	if (ep->magic == SRG52_EEPROM_HDR_MAGIC)
+		return true;
+	else
+		return false;
+}
diff --git a/board/aaeon/srg3352/board_detect.h b/board/aaeon/srg3352/board_detect.h
new file mode 100644
index 0000000000..c7cb216832
--- /dev/null
+++ b/board/aaeon/srg3352/board_detect.h
@@ -0,0 +1,84 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Library to support AAEON SRG3352 family
+ *
+ * Copyright (C) LYD/AAEON Technology Inc.
+ */
+
+#ifndef __BOARD_DETECT_H
+#define __BOARD_DETECT_H
+
+#define SRG52_EEPROM_HDR_MAGIC      0x544F4941	 /* 'AIOT'  */
+#define SRG52_EEPROM_HDR_REV01      0x3130       /* '01'    */
+#define SRG52_EEPROM_HDR_REV        (SRG52_EEPROM_HDR_REV01)
+
+#define SRG52_EEPROM_HDR_ETH_ALEN   (6)
+#define SRG52_EEPROM_HDR_BRD_LEN    (32)
+#define SRG52_EEPROM_HDR_REV_LEN    (2)
+#define SRG52_EEPROM_HDR_SN_LEN     (16)
+#define SRG52_EEPROM_HDR_MNF_LEN    (32)
+#define SRG52_EEPROM_HDR_HWREV_LEN  (2)
+#define SRG52_EEPROM_HDR_HWCFG_LEN  (4)
+#define SRG52_EEPROM_HDR_SWVER_LEN  (2)
+#define SRG52_EEPROM_HDR_SWCFG_LEN  (4)
+#define SRG52_EEPROM_HDR_RVSCS_LEN  (32)
+#define SRG52_EEPROM_HDR_BTCNT_LEN  (4)
+#define SRG52_EEPROM_HDR_CRC16_LEN  (2)
+
+struct  srg52_eeprom_t {
+    u32 magic;				/* header magic numver */
+    u16 rev;				/* header revision, 01 */
+    u8  bname[32];			/* board name */
+    u8 	serial[16];			/* board serial number */
+    u8 	manufacturer[32];	/* manufacture name */
+    u8 	macEth0[6];			/* eth0 address */
+    u8 	macEth1[6];			/* eth1 address */
+    u8 	macBt[6];
+    u8 	macWlan[6];
+    u16 hwRev;				/* hardware revision */
+    u32 hwCfg;				/* hardware configuration */
+    u16 swVer;				/* software verision */
+    u32 swCfg;				/* software configuration */
+    u8 	reservedCus[32];	/* reserve for customer */
+    u32 bootCount;          /* Boot counter */
+    u16 crc16;
+} __attribute__((__packed__));
+
+#define SRG52_EEPROM_SIZE	sizeof(struct srg52_eeprom_t)
+#define SRG52_EEPROM_DATA   ((struct srg52_eeprom_t *)\
+                               TI_SRAM_SCRATCH_BOARD_EEPROM_START)
+/**
+ * set_project_info_env() - Setup default project info environment vars
+ *
+ */
+void set_project_info_env(void);
+/**
+ * set_board_info_env() - Setup commonly used board information environment vars
+ * @name:	Name of the board
+ *
+ * If name is NULL, default_name is used.
+ */
+void set_board_info_env(char *name);
+
+/**
+ * board_ti_set_ethaddr- Sets the ethaddr environment from EEPROM
+ * @index: The first eth<index>addr environment variable to set
+ *
+ * EEPROM should be already read before calling this function.
+ * The EEPROM contains 2 MAC addresses which define the MAC address
+ * range (i.e. first and last MAC address).
+ * This function sets the ethaddr environment variable for all
+ * the available MAC addresses starting from eth<index>addr.
+ */
+void board_ti_set_ethaddr(int index);
+
+/**
+ * board_srg52_was_eeprom_read() - Check to see if the eeprom contents have been read
+ *
+ * This function is useful to determine if the eeprom has already been read and
+ * its contents have already been loaded into memory. It utiltzes the magic
+ * number that the header value is set to upon successful eeprom read.
+ */
+bool board_srg52_was_eeprom_read(void);
+
+#endif	/* __BOARD_DETECT_H */
diff --git a/board/aaeon/srg3352/mux.c b/board/aaeon/srg3352/mux.c
new file mode 100644
index 0000000000..8433fa5d3d
--- /dev/null
+++ b/board/aaeon/srg3352/mux.c
@@ -0,0 +1,201 @@
+/*
+ * mux.c
+ * Copyright (C) 2020 AAEON Technology Inc -- https://www.aaeon.com/
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "board.h"
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart1_pin_mux[] = {
+	{OFFSET(uart1_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART1_RXD */
+	{OFFSET(uart1_txd), (MODE(0) | PULLUDEN)},		/* UART1_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart2_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART2_RXD */
+	{OFFSET(spi0_d0), (MODE(1) | PULLUDEN)},		/* UART2_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart4_pin_mux[] = {
+	{OFFSET(gpmc_wait0), (MODE(6) | PULLUP_EN | RXACTIVE)},	/* UART4_RXD */
+	{OFFSET(gpmc_wpn), (MODE(6) | PULLUDEN)},		/* UART4_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart5_pin_mux[] = {
+	{OFFSET(lcd_data9), (MODE(4) | PULLUP_EN | RXACTIVE)},	/* UART5_RXD */
+	{OFFSET(lcd_data8), (MODE(4) | PULLUDEN)},		/* UART5_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad7), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT7 */
+	{OFFSET(gpmc_ad6), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT6 */
+	{OFFSET(gpmc_ad5), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT5 */
+	{OFFSET(gpmc_ad4), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT4 */
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_7_pin_mux[] = {
+	{OFFSET(ecap0_in_pwm0_out), (MODE(7) | PULLUDEN)},	/* GPIO0_7 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_18_pin_mux[] = {
+	{OFFSET(usb0_drvvbus), (MODE(7) | PULLUDEN)},	/* GPIO0_18 */
+	{-1},
+};
+
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux rgmii2_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(2)},			    /* RGMII2_TCTL */
+	{OFFSET(gpmc_a1), MODE(2) | RXACTIVE},	/* RGMII2_RCTL */
+	{OFFSET(gpmc_a2), MODE(2)},				/* RGMII1_TD3 */
+	{OFFSET(gpmc_a3), MODE(2)},				/* RGMII1_TD2 */
+	{OFFSET(gpmc_a4), MODE(2)},				/* RGMII1_TD1 */
+	{OFFSET(gpmc_a5), MODE(2)},				/* RGMII1_TD0 */
+	{OFFSET(gpmc_a6), MODE(2)},				/* RGMII1_TCLK */
+	{OFFSET(gpmc_a7), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(gpmc_a8), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(gpmc_a9), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(gpmc_a10), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(gpmc_a11), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+void enable_uart1_pin_mux(void)
+{
+	configure_module_pin_mux(uart1_pin_mux);
+}
+
+void enable_uart2_pin_mux(void)
+{
+	configure_module_pin_mux(uart2_pin_mux);
+}
+
+void enable_uart3_pin_mux(void)
+{
+	configure_module_pin_mux(uart3_pin_mux);
+}
+
+void enable_uart4_pin_mux(void)
+{
+	configure_module_pin_mux(uart4_pin_mux);
+}
+
+void enable_uart5_pin_mux(void)
+{
+	configure_module_pin_mux(uart5_pin_mux);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+void enable_board_pin_mux(void)
+{
+	/* Do board-specific muxes. */
+	configure_module_pin_mux(rgmii1_pin_mux);
+	configure_module_pin_mux(rgmii2_pin_mux);
+
+	configure_module_pin_mux(mmc0_pin_mux);
+	configure_module_pin_mux(mmc1_pin_mux);
+}
diff --git a/board/aaeon/srg3352/u-boot.lds b/board/aaeon/srg3352/u-boot.lds
new file mode 100644
index 0000000000..1113057d5f
--- /dev/null
+++ b/board/aaeon/srg3352/u-boot.lds
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2020 AAEON Technology Inc.
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		*(.__image_copy_start)
+		*(.vectors)
+		CPUDIR/start.o (.text*)
+		board/aaeon/srg3352/built-in.o (.text*)
+	}
+
+	/* This needs to come before *(.text*) */
+	.__efi_runtime_start : {
+		*(.__efi_runtime_start)
+	}
+
+	.efi_runtime : {
+		*(.text.efi_runtime*)
+		*(.rodata.efi_runtime*)
+		*(.data.efi_runtime*)
+	}
+
+	.__efi_runtime_stop : {
+		*(.__efi_runtime_stop)
+	}
+
+	.text_rest :
+	{
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	}
+
+	. = ALIGN(4);
+
+	.efi_runtime_rel_start :
+	{
+		*(.__efi_runtime_rel_start)
+	}
+
+	.efi_runtime_rel : {
+		*(.rel*.efi_runtime)
+		*(.rel*.efi_runtime.*)
+	}
+
+	.efi_runtime_rel_stop :
+	{
+		*(.__efi_runtime_rel_stop)
+	}
+
+	. = ALIGN(4);
+
+	.image_copy_end :
+	{
+		*(.__image_copy_end)
+	}
+
+	.rel_dyn_start :
+	{
+		*(.__rel_dyn_start)
+	}
+
+	.rel.dyn : {
+		*(.rel*)
+	}
+
+	.rel_dyn_end :
+	{
+		*(.__rel_dyn_end)
+	}
+
+	.hash : { *(.hash*) }
+
+	.end :
+	{
+		*(.__end)
+	}
+
+	_image_binary_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+/*
+ * Compiler-generated __bss_start and __bss_end, see arch/arm/lib/bss.c
+ * __bss_base and __bss_limit are for linker only (overlay ordering)
+ */
+
+	.bss_start __rel_dyn_start (OVERLAY) : {
+		KEEP(*(.__bss_start));
+		__bss_base = .;
+	}
+
+	.bss __bss_base (OVERLAY) : {
+		*(.bss*)
+		 . = ALIGN(4);
+		 __bss_limit = .;
+	}
+
+	.bss_end __bss_limit (OVERLAY) : {
+		KEEP(*(.__bss_end));
+	}
+
+	.dynsym _image_binary_end : { *(.dynsym) }
+	.dynbss : { *(.dynbss) }
+	.dynstr : { *(.dynstr*) }
+	.dynamic : { *(.dynamic*) }
+	.gnu.hash : { *(.gnu.hash) }
+	.plt : { *(.plt*) }
+	.interp : { *(.interp*) }
+	.gnu : { *(.gnu*) }
+	.ARM.exidx : { *(.ARM.exidx*) }
+}
diff --git a/configs/srg3352_defconfig b/configs/srg3352_defconfig
new file mode 100644
index 0000000000..0021bc34fd
--- /dev/null
+++ b/configs/srg3352_defconfig
@@ -0,0 +1,63 @@
+CONFIG_ARM=y
+CONFIG_ARCH_OMAP2PLUS=y
+CONFIG_TI_COMMON_CMD_OPTIONS=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_AM33XX=y
+CONFIG_TARGET_SRG3352=y
+CONFIG_SPL=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTCOMMAND="if test ${boot_fit} -eq 1; then run update_to_fit; fi; run findfdt; run init_console; run envboot; run distro_bootcmd"
+CONFIG_LOGLEVEL=1
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL_FIT_IMAGE_TINY=y
+CONFIG_SPL_ETH_SUPPORT=y
+# CONFIG_SPL_EXT_SUPPORT is not set
+CONFIG_SPL_MUSB_NEW_SUPPORT=y
+# CONFIG_SPL_NAND_SUPPORT is not set
+CONFIG_SPL_NET_SUPPORT=y
+CONFIG_SPL_NET_VCI_STRING="SRG3352 U-Boot SPL"
+CONFIG_SPL_OS_BOOT=y
+CONFIG_SPL_USB_GADGET=y
+CONFIG_SPL_USB_ETHER=y
+CONFIG_CMD_SPL=y
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_SETEXPR is not set
+# CONFIG_SPL_EFI_PARTITION is not set
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="srg3352"
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_BOOTCOUNT_LIMIT=y
+CONFIG_CLK=y
+CONFIG_CLK_CDCE9XX=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+# CONFIG_MMC_HW_PARTITIONING is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_DM_ETH=y
+CONFIG_MII=y
+CONFIG_DRIVER_TI_CPSW=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_SPL_DM_USB_GADGET=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_USB_MUSB_TI=y
+CONFIG_USB_MUSB_DSPS=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Texas Instruments"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0451
+CONFIG_USB_GADGET_PRODUCT_NUM=0xd022
+CONFIG_USB_ETHER=y
+CONFIG_DYNAMIC_CRC_TABLE=y
+CONFIG_RSA=y
+CONFIG_LZO=y
diff --git a/include/configs/srg3352.h b/include/configs/srg3352.h
new file mode 100644
index 0000000000..84624d8825
--- /dev/null
+++ b/include/configs/srg3352.h
@@ -0,0 +1,351 @@
+/*
+ * am335x_evm.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CONFIG_SRG3352_H
+#define __CONFIG_SRG3352_H
+
+#include <configs/ti_am335x_common.h>
+#include <linux/sizes.h>
+
+/*
+ *	remove TI default macro
+ *  and re-definition them
+ */
+#undef DEFAULT_LINUX_BOOT_ENV
+#define DEFAULT_LINUX_BOOT_ENV \
+	"loadaddr=0x82000000\0" \
+	"kernel_addr_r=0x82000000\0" \
+	"fdtaddr=0x8c000000\0" \
+	"fdt_addr_r=0x8c000000\0" \
+	"rdaddr=0x8c080000\0" \
+	"ramdisk_addr_r=0x8c080000\0" \
+	"scriptaddr=0x80000000\0" \
+	"pxefile_addr_r=0x80100000\0" \
+	"bootm_size=0x10000000\0" \
+	"boot_fdt=try\0"
+
+#ifndef CONFIG_SPL_BUILD
+# define CONFIG_TIMESTAMP
+#endif
+
+#define CONFIG_SYS_BOOTM_LEN		SZ_16M
+
+#define CONFIG_MACH_TYPE		MACH_TYPE_SRG3352
+
+/* Clock Defines */
+#define V_OSCK				24000000  /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+#define CONFIG_SYS_LDSCRIPT		"board/aaeon/srg3352/u-boot.lds"
+
+/* Always 128 KiB env size */
+#define CONFIG_ENV_SIZE			SZ_128K
+
+#define BOOTENV_DEV_LEGACY_MMC(devtypeu, devtypel, instance) \
+	"bootcmd_" #devtypel #instance "=" \
+	"setenv mmcdev " #instance"; "\
+	"setenv bootpart " #instance":2 ; "\
+	"run mmcboot\0"
+
+#define BOOTENV_DEV_NAME_LEGACY_MMC(devtypeu, devtypel, instance) \
+	#devtypel #instance " "
+
+#define BOOTENV_DEV_NAND(devtypeu, devtypel, instance) \
+	"bootcmd_" #devtypel "=" \
+	"run nandboot\0"
+
+#define BOOTENV_DEV_NAME_NAND(devtypeu, devtypel, instance) \
+	#devtypel #instance " "
+
+#if CONFIG_IS_ENABLED(CMD_PXE)
+# define BOOT_TARGET_PXE(func) func(PXE, pxe, na)
+#else
+# define BOOT_TARGET_PXE(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_DHCP)
+# define BOOT_TARGET_DHCP(func) func(DHCP, dhcp, na)
+#else
+# define BOOT_TARGET_DHCP(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(LEGACY_MMC, legacy_mmc, 0) \
+	func(MMC, mmc, 1) \
+	func(LEGACY_MMC, legacy_mmc, 1) \
+	BOOT_TARGET_PXE(func) \
+	BOOT_TARGET_DHCP(func)
+
+#include <config_distro_bootcmd.h>
+
+#define SRG52_BOOTENV \
+	BOOTENV_SHARED_HOST \
+	BOOTENV_SHARED_MMC \
+	BOOTENV_SHARED_USB \
+	BOOTENV_SHARED_EFI \
+	BOOTENV_SHARED_VIRTIO \
+	"boot_prefixes=/boot/ /\0" \
+	"boot_scripts=boot.scr.uimg boot.scr\0" \
+	"boot_script_dhcp=boot.scr.uimg\0" \
+	BOOTENV_BOOT_TARGETS \
+	\
+	"boot_a_script="                                                  \
+		"load ${devtype} ${devnum}:${distro_bootpart} "           \
+			"${scriptaddr} ${prefix}${script}; "              \
+		"source ${scriptaddr}\0"                                  \
+	\
+	"scan_dev_for_scripts="                                           \
+		"for script in ${boot_scripts}; do "                      \
+			"if test -e ${devtype} "                          \
+					"${devnum}:${distro_bootpart} "   \
+					"${prefix}${script}; then "       \
+				"echo Found U-Boot script "               \
+					"${prefix}${script}; "            \
+				"run boot_a_script; "                     \
+				"echo SCRIPT FAILED: continuing...; "     \
+			"fi; "                                            \
+		"done\0"                                                  \
+	\
+	"scan_dev_for_boot="                                              \
+		"echo debug -- scan_dev_for_boot"                           \
+		"echo Scanning ${devtype} "                               \
+				"${devnum}:${distro_bootpart}...; "       \
+		"for prefix in ${boot_prefixes}; do "                     \
+			"run scan_dev_for_scripts; "                      \
+		"done;"                                                   \
+		SCAN_DEV_FOR_EFI                                          \
+		"\0"                                                      \
+	\
+	"scan_dev_for_boot_part="                                         \
+		"part list ${devtype} ${devnum} -bootable devplist; "     \
+		"env exists devplist || setenv devplist 1; "              \
+		"for distro_bootpart in ${devplist}; do "                 \
+			"if fstype ${devtype} "                           \
+					"${devnum}:${distro_bootpart} "   \
+					"bootfstype; then "               \
+				"run scan_dev_for_boot; "                 \
+			"fi; "                                            \
+		"done\0"                                                  \
+	\
+	BOOT_TARGET_DEVICES(BOOTENV_DEV)                                  \
+	\
+	"distro_bootcmd="                       \
+		"echo debug -- run distro_bootcmd; " \
+		"for target in ${boot_targets}; do "                      \
+			"run bootcmd_${target}; "                         \
+		"done\0"
+
+#ifndef CONFIG_SPL_BUILD
+#include <environment/ti/dfu.h>
+#include <environment/ti/mmc.h>
+
+#define DEFAULT_MMC_SRG52_ARGS \
+	"mmcdev=0\0" \
+	"mmcrootfstype=ext4 rootwait\0" \
+	"finduuid=" \
+		"echo debug -- run finduuid; " \
+		"mmc dev ${devnum}; mmc part;"	\
+		"part uuid mmc ${devnum}:${distro_bootpart} uuid;" \
+		"echo debug -- bootpart:${bootpart} uuid: ${uuid}\0" \
+	"args_mmc=run finduuid;setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=PARTUUID=${uuid} rw " \
+		"rootfstype=${mmcrootfstype}\0" \
+	"loadbootscript="\
+		"echo debug -- run loadbootscrip; " \
+		"load mmc ${mmcdev} ${loadaddr} ${bootdir}/boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc${mmcdev} ...; " \
+		"source ${loadaddr}\0" \
+	"bootenvfile=${bootdir}/uEnv.txt\0" \
+	"importbootenv=echo Importing environment from mmc${mmcdev} ...; " \
+		"env import -t ${loadaddr} ${filesize}\0" \
+	"loadbootenv=" \
+		"echo debug -- run loadbootenv;" \
+		"load mmc ${mmcdev} ${loadaddr} ${bootenvfile}\0" \
+	"loadimage=load ${devtype} ${bootpart} ${loadaddr} ${bootdir}/${bootfile}\0" \
+	"loadfdt=load ${devtype} ${bootpart} ${fdtaddr} ${bootdir}/${fdtfile}\0" \
+	"envboot=" \
+		"echo debug -- run envboot, mmcdev:${mmcdev};" \
+		"mmc dev ${mmcdev}; " \
+		"if mmc rescan; then " \
+			"echo SD/MMC found on device ${mmcdev};" \
+			"if run loadbootscript; then " \
+				"run bootscript;" \
+			"else " \
+				"if run loadbootenv; then " \
+					"echo Loaded env from ${bootenvfile};" \
+					"run importbootenv;" \
+				"fi;" \
+				"if test -n $uenvcmd; then " \
+					"echo Running uenvcmd ...;" \
+					"run uenvcmd;" \
+				"fi;" \
+			"fi;" \
+		"fi;\0" \
+	"mmcloados= " \
+		"echo debug -- run mmcloados;" \
+		"run args_mmc; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdtaddr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"mmcboot=" \
+		"echo debug -- run mmcboot;" \
+		"mmc dev ${mmcdev}; " \
+		"setenv devnum ${mmcdev}; " \
+		"setenv devtype mmc; " \
+		"if mmc rescan; then " \
+			"echo SD/MMC found on device ${mmcdev};" \
+			"if run loadimage; then " \
+				"if test ${boot_fit} -eq 1; then " \
+					"run loadfit; " \
+				"else " \
+					"run mmcloados;" \
+				"fi;" \
+			"fi;" \
+		"fi;\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	DEFAULT_LINUX_BOOT_ENV \
+	DEFAULT_MMC_SRG52_ARGS \
+	DEFAULT_FIT_TI_ARGS \
+	"bootpart=0:2\0" \
+	"bootdir=/boot\0" \
+	"bootfile=zImage\0" \
+	"fdtfile=undefined\0" \
+	"console=ttyS0,115200n8\0" \
+	"partitions=" \
+		"uuid_disk=${uuid_gpt_disk};" \
+		"name=bootloader,start=384K,size=1792K," \
+			"uuid=${uuid_gpt_bootloader};" \
+		"name=rootfs,start=128M,size=-,uuid=${uuid_gpt_rootfs}\0" \
+	"optargs=\0" \
+	"ramroot=/dev/ram0 rw\0" \
+	"ramrootfstype=ext4\0" \
+	"ramargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${ramroot} " \
+		"rootfstype=${ramrootfstype}\0" \
+	"loadramdisk=load mmc ${mmcdev} ${rdaddr} ramdisk.gz\0" \
+	"ramboot=echo Booting from ramdisk ...; " \
+		"run ramargs; " \
+		"bootz ${loadaddr} ${rdaddr} ${fdtaddr}\0" \
+	"findfdt="\
+		"if test $board_name = srt3352; then " \
+			"setenv fdtfile am335x-srg3352c.dtb; " \
+		"elif test $board_name = srg3352; then " \
+			"setenv fdtfile am335x-srg3352c.dtb; " \
+		"elif test $board_name = SRG3352C; then " \
+			"setenv fdtfile am335x-srg3352c.dtb; fi; " \
+		"if test $fdtfile = undefined; then " \
+			"echo WARNING: Could not determine device tree to use; fi; \0" \
+	"init_console=" \
+			"setenv console ttyS0,115200n8; \0" \
+	NETARGS \
+	DFUARGS \
+	SRG52_BOOTENV
+#endif
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550_COM1		0x44e09000	/* Base EVM has UART0 */
+#define CONFIG_SYS_NS16550_COM2		0x48022000	/* UART1 */
+#define CONFIG_SYS_NS16550_COM3		0x48024000	/* UART2 */
+#define CONFIG_SYS_NS16550_COM4		0x481a6000	/* UART3 */
+#define CONFIG_SYS_NS16550_COM5		0x481a8000	/* UART4 */
+#define CONFIG_SYS_NS16550_COM6		0x481aa000	/* UART5 */
+
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_EEPROM_ADDR      0x57	/* Main EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2
+
+/* PMIC support */
+#define CONFIG_POWER_TPS65217
+#define CONFIG_POWER_TPS65910
+
+/* SPL */
+/* Bootcount using the RTC block */
+#define CONFIG_SYS_BOOTCOUNT_BE
+/* USB gadget RNDIS */
+
+
+/*
+ * USB configuration.  We enable MUSB support, both for host and for
+ * gadget.  We set USB0 as peripheral and USB1 as host, based on the
+ * board schematic and physical port wired to each.  Then for host we
+ * add mass storage support and for gadget we add both RNDIS ethernet
+ * and DFU.
+ */
+#define CONFIG_USB_MUSB_DISABLE_BULK_COMBINE_SPLIT
+#define CONFIG_AM335X_USB0
+#define CONFIG_AM335X_USB0_MODE	MUSB_PERIPHERAL
+#define CONFIG_AM335X_USB1
+#define CONFIG_AM335X_USB1_MODE MUSB_HOST
+
+/*
+ * Disable MMC DM for SPL build and can be re-enabled after adding
+ * DM support in SPL
+ */
+#ifdef CONFIG_SPL_BUILD
+#undef CONFIG_DM_MMC
+#undef CONFIG_TIMER
+#endif
+
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_USB_ETHER)
+/* Remove other SPL modes. */
+/* disable host part of MUSB in SPL */
+/* disable EFI partitions and partition UUID support */
+#endif
+
+/* USB Device Firmware Update support */
+#ifndef CONFIG_SPL_BUILD
+#define DFUARGS \
+	DFU_ALT_INFO_EMMC \
+	DFU_ALT_INFO_MMC \
+	DFU_ALT_INFO_RAM
+#endif
+
+#if defined(CONFIG_EMMC_BOOT)
+#define CONFIG_SYS_MMC_ENV_DEV		1
+#define CONFIG_SYS_MMC_ENV_PART		0
+#define CONFIG_ENV_OFFSET		0x260000
+#define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_SIZE)
+#define CONFIG_SYS_REDUNDAND_ENVIRONMENT
+#define CONFIG_SYS_MMC_MAX_DEVICE	2
+#endif
+
+/* SPI flash. */
+#define CONFIG_SF_DEFAULT_SPEED		24000000
+
+/* Network. */
+#define CONFIG_PHY_SMSC
+/* Enable Atheros phy driver */
+#define CONFIG_PHY_ATHEROS
+
+#ifdef CONFIG_DRIVER_TI_CPSW
+#define CONFIG_CLOCK_SYNTHESIZER
+#define CLK_SYNTHESIZER_I2C_ADDR 0x65
+#endif
+
+#endif	/* ! __CONFIG_SRG3352_H */
-- 
2.17.1

